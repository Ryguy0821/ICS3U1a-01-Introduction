# Ares, Ross, Ryan - BiSA Encryptor
# A program that uses RSA encryption and binary conversions to create secure encrypted messages with a key system.

import pygame as pg
import math, random


def selPrimes():
	'''Takes in input for 2 prime values (can be semi-prime but not recommended) and checks to see if they are equal. If so, function is re-ran.'''
    print("Call check")
    global p, q
    number = main("Input a prime number for 'p':",False,False)
    p = int(number)
    print(p)
    num = main("Input a prime number for 'q':",False,False)
    q = int(num)
    print(q)
    if p == q:
        print ("They cannot be equal.")
        selPrimes()

def gcd(a, b):
	'''Uses math library to find the greatest common divisor for two values and is used in determining value for the Phi function.'''
    divisor = math.gcd(a, b)
    return divisor

def extEuclidAlgorithm(e, phi):
	'''This particular integration of the Extended Euclidean Algorithm is based on the works of JonCooperWorks on Git. I understand finding the multiplicative inverse of numbers using EEA to a certain degree but had trouble integrating the methods of calculation on Python3. I documented the code as far as I could understand.''' 
	# Assigns dividend and divisor values to 0s and 1s to set up finding the inverse modulus.
	X1 = 0
	X2 = 1
	Y1 = 1
	d = 0

	propPhi = phi # Makes a temporary value for Phi
	while e > 0: # If e = 0 then the calculation is completed and the private key is generated mathematically
		tempOne = propPhi // e # Returns temporary Phi value by no-remainder dividing the current e value
		tempTwo = propPhi - tempOne * e # Sets temporary value for temporary Phi subtract the product of first temporary value times current e value
		propPhi = e # Declares the new temporary phi value as the current e value
		e = tempTwo # Sets the e value for second temporary value
        # Sets up x & y variables from first temporary value product times 0 and 1 values
		X = X2 - tempOne * X1
		Y = d - tempOne * Y1
		# Uses the X and Y values to reassign new values and complete finding the inverse modulus
		X2 = X1
		X1 = X
		d = Y1
		Y1 = Y

	if propPhi == 1: # When inverse modulus is found, it returns the private key which is the sum of the d and phi value
		return d + phi

def coprimeCorrector(phi):
	'''Corrects greatest common divisor for phi(n) and e to assume whether or not e is coprime with phi(n) and assign it to a new coprime value if not coprime.'''
	global e
	x = gcd(e, phi)
	while x != 1: # If value is coprime, the gcd of e and phi must be equal to 1
		e = random.randint(2, phi - 1)
		x = gcd(e, phi)

def coprimeConstant(phi):
	'''First selection of the coprime value for e but doesn't check if its coprime (redundant function, but who cares? Let's make it object oriented anyways...)'''
	global e
	e = random.randint(2, phi - 1)

def primeCheck(x):
	'''Checks if inputted values for p and q (when inputted in parameters) are prime. Unfortuneately this algorithm doesn't account for semi-primes. Semi-primes work most of the time in RSA but sometimes do not, causing the plaintext to not equal the original text.'''
    yesPrime = False
    if x < 2: # Values under 2 can't be prime, duh
        return yesPrime
    if x % 2 == 0: # If the value mod 2 is equal to 0 then it obviously can't be prime because theres no remainder
        return yesPrime
    for x in range(3, int(math.sqrt(x))+ 2, 2): # This is a universal mathematical formula for determining if a number is prime. Start from 3, take the root of the number and add 2, then go up by intervals of 2. Check if the value mod 2 is equal to 0, and if so, it is not prime
        if x % 2 == 0:
            return yesPrime
    yesPrime = True # If all checks run through, the number is prime (or semi-prime) and the result is returned as True
    return yesPrime

def primeFinalCheck(p, q):
	'''Calls on primeCheck(x) function and checks if values are under 100 to ensure a decent amount of security for encryption'''
	if p < 100:
		print ("To ensure maximum security, please use values atleast 3 digits long.")
		return False
	if q < 100:
		print ("To ensure maximum security, please use values atleast 3 digits long.")
		return False
	if (primeCheck(p) and primeCheck(q)) == False: # Simply checks if each prime checks are False
		print ("Both numbers must be prime.")
		return False
	else:
		return True

def keygen(p, q):
	'''Generates the public and private keys for the message inputted calling upon generating the phi, phi(n), n, d (private key calculated by inverse modulo using Extended Euclidean mathematics), and returns the keys as a result of tuples (lists were inefficient).'''
	global e
	phi = (p-1)*(q-1) # Golden ratio function
	n = (p * q)
	coprimeConstant(phi) # Generates 'e', or phi(n)
	coprimeCorrector(phi) # Corrects phi(n) if it isn't coprime
	d = extEuclidAlgorithm(e, phi) # Generates private key using Extended Euclidean mathematics by finding inverse modulus
	return ((e, n), (d, n)) # Returns keys as a result of tuples, we used lists earlier but were inefficient

def encryptor(privKey, confidential):
	'''Encrypts message by using the private key to encrypt and plugging in numbers for the RSA universal equation. Uses a list to store the encrypted ASCII values.'''
	trueText = []
	key, n = privKey # Assigns values from tuple version of key
	for i in range(0, len(confidential)):
		trueText.append((ord(confidential[i]) ** key) % n) # Appends encrypted ASCII values to a list
	return trueText

def decryptor(publKey, confidential):
	'''Uses public key to encrypt ciphertext. Takes in string version of ciphertext and turns it into a tuple, assigning it for key and n values, assigning it to a list, then plugging them into the universal RSA decryption equation.'''
	trueText = []
	keytuple = tuple(int(i) for i in publKey.split(",")) # Converts to tuple for readability purposes
	key, n = keytuple
	true = list(map(int, confidential.split())) # Turns ciphertext into list elements
	for i in range(0, len(true)):
		trueText.append(chr((true[i] ** key) % n)) # Plugs values into equation to decrypt them all using public key
	return trueText

def textSort(x):
	'''Sorts text to look nice when displayed.'''
	trueText = ""
	for i in range(len(x)):
		trueText = trueText + str(x[i])
	return trueText

def ciphertextSort(x):
	'''Sorts ciphertext to not only look nice, but come out in proper format for easy copy and pasting.'''
	trueText = ""
	for i in range(len(x)):
		trueText = trueText + str(x[i]) + " "
	return trueText[:-1]

# Graphical/integration functions start here:

def textDisplay(text,x,y,black):
    font = pg.font.SysFont("timesnewroman",20)
    text = font.render(text, True, black)
    gameDisplay.blit(text,(x*0.45,y*0.4))
    pg.display.flip()

def background(Img):
    gameDisplay.blit(Img,(0,0))

def main(encdec,encrypting,decrypting):
    screen = pg.display.set_mode((1224, 800))
    font = pg.font.Font(None, 32)
    clock = pg.time.Clock()
    input_box = pg.Rect(100, 100, 140, 32)
    color_inactive = pg.Color('lightskyblue3')
    color_active = pg.Color('black')
    color = color_inactive
    active = False
    text = ''
    done = False

    while not done:
        for event in pg.event.get():
            if event.type == pg.QUIT:
                done = True
            if event.type == pg.MOUSEBUTTONDOWN:
                # If the user clicked on the input_box rect.
                if input_box.collidepoint(event.pos):
                    # Toggle the active variable.
                    active = not active
                else:
                    active = False
                # Change the current color of the input box.
                color = color_active if active else color_inactive
            if event.type == pg.KEYDOWN:
                if active:
                    if event.key == pg.K_RETURN:
                        message = text

                        if encrypting == True:
                            selPrimes()
                        
                            while True:
                                if primeFinalCheck(p, q) == False:
                                    selPrimes()
                                else:
                                    break
                            
                            print("Public, Private Key:", keygen(p, q))
                            publKey, privKey = keygen(p, q)
                            print("Encrypting... (this may take a while)")
                            ciphertextOne = encryptor(privKey, message)
                            ciphertext = ciphertextSort(ciphertextOne)
                            print ("Ciphertext:", ciphertext)

            
                        text = ''
                    elif event.key == pg.K_BACKSPACE:
                        text = text[:-1]
                    else:
                        text += event.unicode

        screen.fill((60, 180, 210))
        # Render the current text.
        txt_surface = font.render(text, True, color)
        # Resize the box if the text is too long.
        width = max(200, txt_surface.get_width()+10)
        input_box.w = width
        # Blit the text.
        screen.blit(txt_surface, (input_box.x+5, input_box.y+5))
        # Blit the input_box rect.
        pg.draw.rect(screen, color, input_box, 2)
        textDisplay(str(encdec),displayWidth*0.35,displayHeight*0.15,black)
     

        pg.display.flip()
        clock.tick(30)
    
        
def menu():
    background(backgroundImg)
    rectplace = pg.draw.rect(gameDisplay, (white),(852, 400, 150, 20))
    encryptRectplace = pg.draw.rect(gameDisplay, (white),(885, 560, 80, 20))
    decryptRectplace = pg.draw.rect(gameDisplay, (white),(890, 680, 80, 20))
    textDisplay("BiSA-Encryption",displayHeight,displayWidth,black)
    textDisplay("Encrypt",displayWidth*1.62,displayHeight*0.85,black)
    textDisplay("Decrypt",displayWidth*1.62,displayHeight*1.1,black)
    
pg.init()
displayHeight = 1224
displayWidth = 800

p = 0
q = 0
e = 0
d = 0



white = (255,255,255)
black = (0,0,0)

backgroundImg = pg.image.load('background.png.jpg')
backgroundImg = pg.transform.scale(backgroundImg,(1224,800))

gameDisplay = pg.display.set_mode((displayHeight,displayWidth))
pg.display.set_caption('BiSA-Encryption')
clock = pg.time.Clock()

gameDisplay.fill(white)

rectplace = pg.draw.rect(gameDisplay, (white),(displayHeight,displayWidth, 150, 20))
encryptRectplace = pg.draw.rect(gameDisplay, (white),(885, 560, 80, 20))
decryptRectplace = pg.draw.rect(gameDisplay, (white),(890, 680, 80, 20))

menu()

crashed = False

while not crashed:
    for event in pg.event.get():
        if event.type == pg.QUIT:
            crashed = True

    pos = pg.mouse.get_pos()
    pressed1, pressed2, pressed3 = pg.mouse.get_pressed()

    menu()

    if encryptRectplace.collidepoint(pos) and pressed1:
        background(backgroundImg)
        main("Encrypt Message:",True,False)
        
        
        #textDisplay(encryptedMessage,2000,1550,black)        

    if decryptRectplace.collidepoint(pos) and pressed1:
        background(backgroundImg)
        message = main("Decrypt:",False,True)
        print ("decrypt")
        print(message)
        print ("Decrypting... (this may take a while)")
        publKeyin = input("Input the public key (do not input the brackets): ")
        ciphertextin = input("Input the ciphertext: ")
        plaintext = decryptor(publKeyin, ciphertextin)
        print ("Plaintext:", textSort(plaintext))
   
        
        #textDisplay(decryptedMessage,2000,1550,black)
